"""A collection of classes used in the 'machine code' generated by Auto Maple's compiler for each routine."""

from src.common import config, settings, utils
import csv
import json
import os
import re
from os.path import splitext, basename
from src.routine.components import Point, Label, Jump, Setting, Command, SYMBOLS, SkillRotation
from src.routine.layout import Layout
import random


def _save_failed_frame(frame, failed_dir, reason=""):
    """Save frame to failed_detections/failed_minimap_finder_{n}.jpg for inspection (BGR so test script matches)."""
    try:
        import cv2
        os.makedirs(failed_dir, exist_ok=True)
        # Save as BGR so when loaded with cv2.imread it matches live matching (mss gives BGRA)
        save_frame = frame
        if frame.ndim == 3 and frame.shape[2] == 4:
            save_frame = cv2.cvtColor(frame, cv2.COLOR_BGRA2BGR)
        existing = [f for f in os.listdir(failed_dir) if re.match(r"failed_minimap_finder_\d+\.jpg", f)]
        nums = [int(re.search(r"\d+", f).group()) for f in existing]
        n = max(nums, default=0) + 1
        path = os.path.join(failed_dir, f"failed_minimap_finder_{n}.jpg")
        cv2.imwrite(path, save_frame)
        print(f"[~] Saved frame for inspection ({reason}): {path}")
    except Exception as e:
        print(f"[!] Could not save failed frame: {e}")


def update(func):
    """
    Decorator function that updates both the displayed routine and details
    for all mutative Routine operations.
    """

    def f(self, *args, **kwargs):
        result = func(self, *args, **kwargs)
        config.gui.set_routine(self.display)
        config.gui.view.details.update_details()
        return result
    return f


def dirty(func):
    """Decorator function that sets the dirty bit for mutative Routine operations."""

    def f(self, *args, **kwargs):
        result = func(self, *args, **kwargs)
        self.dirty = True
        return result
    return f


class Routine:
    """Describes a routine file in Auto Maple's custom 'machine code'."""

    def __init__(self):
        self.dirty = False
        self.path = ''
        self.labels = {}
        self.index = 0
        self.sequence = []
        self.display = []       # Updated alongside sequence
        self.auto_mode = False  # True when loaded auto.csv: resolve waypoints at run from minimap match

    @dirty
    @update
    def set(self, arr):
        self.sequence = arr
        self.display = [str(x) for x in arr]

    @dirty
    @update
    def append_component(self, p):
        self.sequence.append(p)
        self.display.append(str(p))

    @dirty
    @update
    def append_command(self, i, c):
        """Appends Command object C to the Point at index I in the sequence."""

        target = self.sequence[i]
        target.commands.append(c)

    @dirty
    @update
    def move_component_up(self, i):
        """Moves the component at index I upward if possible."""

        if i > 0:
            temp_s = self.sequence[i-1]
            temp_d = self.display[i-1]
            self.sequence[i-1] = self.sequence[i]
            self.display[i-1] = self.display[i]
            self.sequence[i] = temp_s
            self.display[i] = temp_d
            return i - 1
        return i

    @dirty
    @update
    def move_component_down(self, i):
        if i < len(self.sequence) - 1:
            temp_s = self.sequence[i+1]
            temp_d = self.display[i+1]
            self.sequence[i+1] = self.sequence[i]
            self.display[i+1] = self.display[i]
            self.sequence[i] = temp_s
            self.display[i] = temp_d
            return i + 1
        return i

    @dirty
    @update
    def move_command_up(self, i, j):
        """
        Within the Point at routine index I, moves the Command at index J upward
        if possible and updates the Edit UI.
        """

        point = self.sequence[i]
        if j > 0:
            temp = point.commands[j-1]
            point.commands[j-1] = point.commands[j]
            point.commands[j] = temp
            return j - 1
        return j

    @dirty
    @update
    def move_command_down(self, i, j):
        point = self.sequence[i]
        if j < len(point.commands) - 1:
            temp = point.commands[j+1]
            point.commands[j+1] = point.commands[j]
            point.commands[j] = temp
            return j + 1
        return j

    @dirty
    @update
    def delete_component(self, i):
        """Deletes the Component at index I."""

        self.sequence.pop(i)
        self.display.pop(i)

    @dirty
    @update
    def delete_command(self, i, j):
        """Within the Point at routine index I, deletes the Command at index J."""

        point = self.sequence[i]
        point.commands.pop(j)

    @update
    def update_component(self, i, new_kwargs):
        target = self.sequence[i]
        try:
            target.update(**new_kwargs)
            self.display[i] = str(target)
            self.dirty = True
        except (ValueError, TypeError) as e:
            print(f"\n[!] Found invalid arguments for '{target.__class__.__name__}':")
            print(f"{' ' * 4} -  {e}")

    @update
    def update_command(self, i, j, new_kwargs):
        target = self.sequence[i].commands[j]
        try:
            target.update(**new_kwargs)
            self.display[i] = str(self.sequence[i])
            self.dirty = True
        except (ValueError, TypeError) as e:
            print(f"\n[!] Found invalid arguments for '{target.__class__.__name__}':")
            print(f"{' ' * 4} -  {e}")

    @utils.run_if_enabled
    def step(self):
        """Increments config.seq_index and wraps back to 0 at the end of config.sequence."""
        self.index = random.randint(0, len(self.sequence) - 1)
        # self.index = (self.index + 1) % len(self.sequence)

    def save(self, file_path):
        """Encodes and saves the current Routine at location PATH."""

        result = []
        for item in self.sequence:
            result.append(item.encode())
            if isinstance(item, Point):
                for c in item.commands:
                    result.append(' ' * 4 + c.encode())
        result.append('')

        with open(file_path, 'w') as file:
            file.write('\n'.join(result))
        self.dirty = False

        utils.print_separator()
        print(f"[~] Saved routine to '{basename(file_path)}'.")

    def clear(self):
        self.index = 0
        self.set([])
        self.dirty = False
        self.path = ''
        self.auto_mode = False
        config.layout = None
        settings.reset()

        config.gui.clear_routine_info()

    def load(self, file=None):
        """
        Attempts to load FILE into a sequence of Components. If no file path is provided, attempts to
        load the previous routine file.
        :param file:    The file's path.
        :return:        None
        """

        utils.print_separator()
        print(f"[~] Loading routine '{basename(file)}':")

        if not file:
            if self.path:
                file = self.path
                print(' *  File path not provided, using previously loaded routine')
            else:
                print('[!] File path not provided, no routine was previously loaded either')
                return False

        ext = splitext(file)[1]
        if ext != '.csv':
            print(f" !  '{ext}' is not a supported file extension.")
            return False

        self.clear()
        # Reset so a CSV without the setting doesn't inherit previous routine's mode
        settings.skill_rotation_mode = False
        settings.skill_rotation_duration = 5.0

        # Compile and Link
        self.compile(file)
        for c in self.sequence:
            if isinstance(c, Jump):
                c.bind()

        self.dirty = False
        self.path = file
        # auto.csv with nothing (or only $ settings): resolve waypoints when bot runs via minimap match
        if basename(file).lower() == 'auto.csv':
            self.auto_mode = True
            print(' ~  Auto routine: waypoints will be resolved from minimap match when you start.')
        config.layout = Layout.load(file)
        config.gui.view.status.set_routine(basename(file))
        config.gui.edit.minimap.draw_default()
        print(f" ~  Finished loading routine '{basename(splitext(file)[0])}'.")

    def compile(self, file):
        self.labels = {}
        with open(file, newline='') as f:
            csv_reader = csv.reader(f, skipinitialspace=True)
            curr_point = None
            line = 1
            for row in csv_reader:
                result = self._eval(row, line)
                if result:
                    if isinstance(result, Command):
                        if curr_point:
                            curr_point.commands.append(result)
                    else:
                        self.append_component(result)
                        if isinstance(result, Point):
                            curr_point = result
                line += 1

    def _eval(self, row, i):
        if row and isinstance(row, list):
            first, rest = row[0].strip().lower(), row[1:]
            if not first:
                return
            args, kwargs = utils.separate_args(rest)
            line_error = f' !  Line {i}: '

            if first in SYMBOLS:
                c = SYMBOLS[first]
            elif first in config.bot.command_book:
                c = config.bot.command_book[first]
            else:
                print(line_error + f"Command '{first}' does not exist.")
                return

            try:
                obj = c(*args, **kwargs)
                if isinstance(obj, Label):
                    obj.set_index(len(self))
                    self.labels[obj.label] = obj
                return obj
            except (ValueError, TypeError) as e:
                print(line_error + f"Found invalid arguments for '{c.__name__}':")
                print(f"{' ' * 4} -  {e}")

    def resolve_auto_routine(self, skill_rotation_duration=5.0, move_tolerance=0.075):
        """
        Resolve auto routine: if a minimap was selected via File > Load Minimap, use it and skip OCR.
        Otherwise match current game minimap to a PNG in assets/minimaps (OCR), then build waypoints.
        If no asset matches, use the live minimap from config.capture. Sets sequence to Points with
        SkillRotation at each; enables skill_rotation_mode. Call when bot is enabled and auto_mode is True.
        """
        from src.map.waypoints_from_map import (
            find_matching_map,
            waypoints_from_map_path,
            waypoints_from_map_image,
        )
        root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
        failed_dir = os.path.join(root, 'failed_detections')
        map_path = None
        waypoints = None

        # User selected a minimap (File > Load Minimap): use it directly, no OCR
        selected = getattr(config, 'selected_minimap_path', None)
        if selected and os.path.isfile(selected):
            map_path = selected
            waypoints = waypoints_from_map_path(map_path)
            print('\n[~] Auto routine: using selected minimap (OCR skipped).')
        else:
            # No selection: use frame + OCR to match a map, or live minimap
            frame = config.capture.frame if config.capture else None
            minimap = config.capture.get_minimap_from_frame(frame) if config.capture and frame is not None else None
            if minimap is None:
                print('\n[!] Auto routine: no minimap available yet (capture not ready).')
                if frame is not None:
                    _save_failed_frame(frame, failed_dir, "minimap_extract")
                return False
            minimaps_dir = os.path.join(root, 'assets', 'minimaps')
            map_path = find_matching_map(frame, minimaps_dir, threshold=0.7)
            if map_path:
                waypoints = waypoints_from_map_path(map_path)
            else:
                print('\n[~] Auto routine: no minimap found in assets/minimaps; using current game minimap for waypoints.')
                if frame is not None:
                    _save_failed_frame(frame, failed_dir, "minimap_match")
                waypoints = waypoints_from_map_image(minimap)
        if not waypoints:
            print('\n[!] Auto routine: no waypoints (no platforms detected on minimap).')
            return False
        sequence = []
        for w in waypoints:
            p = Point(
                x=w['x'], y=w['y'],
                frequency=1, skip='False', adjust='True'
            )
            p.commands = [SkillRotation(duration=skill_rotation_duration)]
            sequence.append(p)
        self.sequence = sequence
        self.display = [str(x) for x in sequence]
        self.labels = {}
        self.index = 0
        self.auto_mode = False
        settings.skill_rotation_mode = True
        settings.skill_rotation_duration = skill_rotation_duration
        settings.move_tolerance = move_tolerance
        config.gui.set_routine(self.display)
        config.gui.view.details.update_details()
        utils.print_separator()
        source = os.path.basename(map_path) if map_path else "current minimap"
        print(f"[~] Auto routine resolved: {source}, {len(sequence)} waypoints, skill rotation {skill_rotation_duration}s.")
        return True

    @dirty
    @update
    def load_waypoints_from_json(self, path, skill_rotation_duration=5):
        """
        Load waypoints from a JSON file (e.g. from mark_platform_centers.py output).
        Each waypoint becomes a Point with SkillRotation(duration=...) as its only command.
        Call after a command book is loaded (so move/adjust exist).
        """
        with open(path, 'r') as f:
            waypoints = json.load(f)
        sequence = []
        for w in waypoints:
            p = Point(
                x=w['x'], y=w['y'],
                frequency=1, skip='False', adjust='True'
            )
            p.commands = [SkillRotation(duration=skill_rotation_duration)]
            sequence.append(p)
        self.sequence = sequence
        self.display = [str(x) for x in sequence]
        self.labels = {}
        self.index = 0
        self.path = path

    @staticmethod
    def get_all_components():
        """Returns a dictionary mapping all creatable Components to their names."""

        options = config.bot.command_book.dict.copy()
        for e in (Point, Label, Jump, Setting):
            options[e.__name__.lower()] = e
        return options

    def __getitem__(self, i):
        return self.sequence[i]

    def __len__(self):
        return len(self.sequence)
